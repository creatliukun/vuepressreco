import{_ as i,c as e,e as a,o as n}from"./app-C-L3CEF_.js";const t={};function s(r,l){return n(),e("div",null,l[0]||(l[0]=[a('<h1 id="浏览器渲染" tabindex="-1"><a class="header-anchor" href="#浏览器渲染"><span>浏览器渲染</span></a></h1><p>浏览器的渲染过程是一个复杂且高度优化的过程，涉及 HTML、CSS 和 JavaScript 的解析与执行。以下是详细的步骤说明：</p><hr><h2 id="_1-html-解析" tabindex="-1"><a class="header-anchor" href="#_1-html-解析"><span>1. <strong>HTML 解析</strong></span></a></h2><h3 id="_1-1-初始阶段" tabindex="-1"><a class="header-anchor" href="#_1-1-初始阶段"><span>1.1 初始阶段</span></a></h3><ul><li>当浏览器接收到 HTML 文件时，会从上到下逐行解析。</li><li>解析过程中，HTML 被转换为一个 <strong>DOM（Document Object Model）树</strong>，这是页面结构的表示形式。</li></ul><h3 id="_1-2-标签解析" tabindex="-1"><a class="header-anchor" href="#_1-2-标签解析"><span>1.2 标签解析</span></a></h3><ul><li>浏览器遇到标签时，会根据标签类型进行不同的处理： <ul><li><strong>普通标签</strong>：直接创建对应的 DOM 节点并插入到 DOM 树中。</li><li><strong>脚本标签 <code>&lt;script&gt;</code></strong>： <ul><li>如果是内联脚本（<code>&lt;script&gt;...&lt;/script&gt;</code>），浏览器会暂停 HTML 解析，立即执行脚本。</li><li>如果是外部脚本（<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>），浏览器会发起网络请求下载脚本文件，并在下载完成后执行。</li><li>默认情况下，脚本是阻塞的（blocking），即 HTML 解析会被暂停，直到脚本执行完成。</li></ul></li><li><strong>样式表 <code>&lt;link&gt;</code></strong>： <ul><li>遇到 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 时，浏览器会发起 CSS 文件的下载请求。</li><li>CSS 是渲染阻塞的（render-blocking），即浏览器不会开始渲染页面，直到所有 CSS 文件加载完成。</li></ul></li></ul></li></ul><h3 id="_1-3-dom-构建完成" tabindex="-1"><a class="header-anchor" href="#_1-3-dom-构建完成"><span>1.3 DOM 构建完成</span></a></h3><ul><li>当 HTML 文件完全解析后，DOM 树构建完成。</li></ul><hr><h2 id="_2-css-解析" tabindex="-1"><a class="header-anchor" href="#_2-css-解析"><span>2. <strong>CSS 解析</strong></span></a></h2><h3 id="_2-1-下载与解析" tabindex="-1"><a class="header-anchor" href="#_2-1-下载与解析"><span>2.1 下载与解析</span></a></h3><ul><li>浏览器下载所有引用的 CSS 文件，并将其解析为 <strong>CSSOM（CSS Object Model）树</strong>。</li><li>CSSOM 是一个类似于 DOM 的树状结构，用于表示页面的样式规则。</li></ul><h3 id="_2-2-样式计算" tabindex="-1"><a class="header-anchor" href="#_2-2-样式计算"><span>2.2 样式计算</span></a></h3><ul><li>浏览器将 DOM 树和 CSSOM 树结合起来，计算每个 DOM 节点的具体样式。</li><li>这个过程称为 <strong>样式计算（Style Calculation）</strong>，结果是一个包含每个节点样式的映射表。</li></ul><hr><h2 id="_3-布局-layout-reflow" tabindex="-1"><a class="header-anchor" href="#_3-布局-layout-reflow"><span>3. <strong>布局（Layout/Reflow）</strong></span></a></h2><h3 id="_3-1-布局计算" tabindex="-1"><a class="header-anchor" href="#_3-1-布局计算"><span>3.1 布局计算</span></a></h3><ul><li>在样式计算完成后，浏览器进入布局阶段。</li><li>布局阶段的主要任务是确定每个 DOM 节点在页面中的位置和尺寸。</li><li>这个过程也被称为 <strong>回流（Reflow）</strong> 或 <strong>重排（Relayout）</strong>。</li></ul><h3 id="_3-2-布局树" tabindex="-1"><a class="header-anchor" href="#_3-2-布局树"><span>3.2 布局树</span></a></h3><ul><li>布局阶段生成一个 <strong>布局树（Layout Tree）</strong>，它是 DOM 树的一个子集，仅包含可见的节点（如 <code>display: none</code> 的节点不会出现在布局树中）。</li></ul><hr><h2 id="_4-绘制-painting" tabindex="-1"><a class="header-anchor" href="#_4-绘制-painting"><span>4. <strong>绘制（Painting）</strong></span></a></h2><h3 id="_4-1-绘制准备" tabindex="-1"><a class="header-anchor" href="#_4-1-绘制准备"><span>4.1 绘制准备</span></a></h3><ul><li>在布局完成后，浏览器进入绘制阶段。</li><li>绘制阶段的主要任务是将布局树转换为屏幕上的像素。</li><li>浏览器会为每个节点生成多个图层（Layers），每个图层负责绘制特定的内容（如背景、文本、边框等）。</li></ul><h3 id="_4-2-绘制顺序" tabindex="-1"><a class="header-anchor" href="#_4-2-绘制顺序"><span>4.2 绘制顺序</span></a></h3><ul><li>绘制顺序遵循一定的规则，通常包括以下内容： <ol><li>背景颜色或图片</li><li>边框</li><li>文本内容</li><li>其他装饰性元素（如阴影、渐变等）</li></ol></li></ul><hr><h2 id="_5-合成-compositing" tabindex="-1"><a class="header-anchor" href="#_5-合成-compositing"><span>5. <strong>合成（Compositing）</strong></span></a></h2><h3 id="_5-1-图层合并" tabindex="-1"><a class="header-anchor" href="#_5-1-图层合并"><span>5.1 图层合并</span></a></h3><ul><li>在绘制完成后，浏览器进入合成阶段。</li><li>合成阶段的主要任务是将所有图层合并为最终的画面，并显示在屏幕上。</li><li>浏览器会利用 GPU 加速这一过程，以提高性能。</li></ul><h3 id="_5-2-动画优化" tabindex="-1"><a class="header-anchor" href="#_5-2-动画优化"><span>5.2 动画优化</span></a></h3><ul><li>如果页面中有动画效果，浏览器会尽量避免重新计算布局或重新绘制，而是通过调整图层的透明度、位置等属性来实现动画。</li></ul><hr><h2 id="_6-javascript-执行" tabindex="-1"><a class="header-anchor" href="#_6-javascript-执行"><span>6. <strong>JavaScript 执行</strong></span></a></h2><h3 id="_6-1-脚本执行" tabindex="-1"><a class="header-anchor" href="#_6-1-脚本执行"><span>6.1 脚本执行</span></a></h3><ul><li>在 HTML 解析过程中，遇到 <code>&lt;script&gt;</code> 标签时，浏览器会暂停 HTML 解析并执行脚本。</li><li>如果脚本修改了 DOM 或 CSSOM，可能会触发重新布局或重新绘制。</li></ul><h3 id="_6-2-异步脚本" tabindex="-1"><a class="header-anchor" href="#_6-2-异步脚本"><span>6.2 异步脚本</span></a></h3><ul><li>使用 <code>async</code> 属性的脚本会在后台下载，下载完成后立即执行，但不会阻塞 HTML 解析。</li><li>使用 <code>defer</code> 属性的脚本也会在后台下载，但在 HTML 解析完成后按顺序执行。</li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>浏览器的渲染过程可以概括为以下几个关键阶段：</p><ol><li><strong>HTML 解析</strong>：生成 DOM 树。</li><li><strong>CSS 解析</strong>：生成 CSSOM 树。</li><li><strong>样式计算</strong>：结合 DOM 和 CSSOM，计算每个节点的样式。</li><li><strong>布局</strong>：计算每个节点的位置和尺寸。</li><li><strong>绘制</strong>：将布局树转换为屏幕上的像素。</li><li><strong>合成</strong>：将图层合并为最终画面。</li><li><strong>JavaScript 执行</strong>：动态修改 DOM 或 CSSOM，可能触发重新布局或重新绘制。</li></ol><p>这些阶段环环相扣，任何一个阶段的延迟都会影响整体渲染性能。因此，在开发中应尽量减少阻塞操作（如大文件下载、复杂的样式计算等），以提升页面加载速度和用户体验。</p>',45)]))}const h=i(t,[["render",s]]),c=JSON.parse('{"path":"/blogs/brower/2025/03300030.html","title":"浏览器渲染","lang":"en-US","frontmatter":{"title":"浏览器渲染","date":"2025-03-30T00:00:00.000Z","tags":["brower"],"categories":["Brower"]},"headers":[{"level":2,"title":"1. HTML 解析","slug":"_1-html-解析","link":"#_1-html-解析","children":[{"level":3,"title":"1.1 初始阶段","slug":"_1-1-初始阶段","link":"#_1-1-初始阶段","children":[]},{"level":3,"title":"1.2 标签解析","slug":"_1-2-标签解析","link":"#_1-2-标签解析","children":[]},{"level":3,"title":"1.3 DOM 构建完成","slug":"_1-3-dom-构建完成","link":"#_1-3-dom-构建完成","children":[]}]},{"level":2,"title":"2. CSS 解析","slug":"_2-css-解析","link":"#_2-css-解析","children":[{"level":3,"title":"2.1 下载与解析","slug":"_2-1-下载与解析","link":"#_2-1-下载与解析","children":[]},{"level":3,"title":"2.2 样式计算","slug":"_2-2-样式计算","link":"#_2-2-样式计算","children":[]}]},{"level":2,"title":"3. 布局（Layout/Reflow）","slug":"_3-布局-layout-reflow","link":"#_3-布局-layout-reflow","children":[{"level":3,"title":"3.1 布局计算","slug":"_3-1-布局计算","link":"#_3-1-布局计算","children":[]},{"level":3,"title":"3.2 布局树","slug":"_3-2-布局树","link":"#_3-2-布局树","children":[]}]},{"level":2,"title":"4. 绘制（Painting）","slug":"_4-绘制-painting","link":"#_4-绘制-painting","children":[{"level":3,"title":"4.1 绘制准备","slug":"_4-1-绘制准备","link":"#_4-1-绘制准备","children":[]},{"level":3,"title":"4.2 绘制顺序","slug":"_4-2-绘制顺序","link":"#_4-2-绘制顺序","children":[]}]},{"level":2,"title":"5. 合成（Compositing）","slug":"_5-合成-compositing","link":"#_5-合成-compositing","children":[{"level":3,"title":"5.1 图层合并","slug":"_5-1-图层合并","link":"#_5-1-图层合并","children":[]},{"level":3,"title":"5.2 动画优化","slug":"_5-2-动画优化","link":"#_5-2-动画优化","children":[]}]},{"level":2,"title":"6. JavaScript 执行","slug":"_6-javascript-执行","link":"#_6-javascript-执行","children":[{"level":3,"title":"6.1 脚本执行","slug":"_6-1-脚本执行","link":"#_6-1-脚本执行","children":[]},{"level":3,"title":"6.2 异步脚本","slug":"_6-2-异步脚本","link":"#_6-2-异步脚本","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1743354643000,"updatedTime":1743354643000,"contributors":[{"name":"creatliukun","email":"952476356@qq.com","commits":1}]},"filePathRelative":"blogs/brower/2025/03300030.md"}');export{h as comp,c as data};
