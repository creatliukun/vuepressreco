---
title: vite 的使用
date: 2025-03-29
tags:
 - module
categories:
 # 模块化
 - Modularization
---

# vite的使用
## 关于Vite
是一种新型前端构建工具，能够显著提升前端开发体验，它主要由两部分组成：
+ 1. 一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热替换（HMR）。
+ 2. 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。
### 浏览器支持
对于生产构建，默认情况下 Vite 的目标浏览器支持 原生 ES 模块、原生 ESM 动态导入、import.meta、nullish coalescing 和 BigInt。旧版浏览器可以通过官方的 @vitejs/plugin-legacy。

### 搭建一个 Vite 项目
+ 注意： 兼容性注意
Vite 需要 Node.js 版本 18+ 或 20+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。
```bash
pnpm create vite
# 然后按照提示操作即可！
```
注意：为什么选择pnpm，不使用npm呢？
1. 磁盘空间优化
pnpm 使用内容可寻址存储（CAS）来管理依赖项。所有安装的包都会被存放在一个全局存储中，项目本地只会创建符号链接到这些包。这种方式可以显著减少磁盘空间占用。
npm 默认会将每个项目的依赖项完全复制到 node_modules 中，可能导致重复依赖占用大量空间。
2. 性能提升
pnpm 在安装依赖时速度更快，因为它只需要从全局存储中复制文件或创建符号链接，而不是重新下载整个依赖树。
npm 的安装过程可能更慢，尤其是在有大量依赖的情况下，因为需要逐个下载和解压依赖。
3. 严格的依赖管理
pnpm 确保了依赖树的严格性，避免了 node_modules 中出现不必要的嵌套结构。这有助于减少潜在的版本冲突问题。
npm 可能会在某些情况下允许重复的依赖版本存在，导致依赖树变得复杂且难以维护。
4. 安全性
pnpm 的设计减少了对文件系统的写操作，从而降低了恶意代码篡改的风险。
npm 的安装过程可能会涉及更多的文件系统操作，增加了潜在的安全隐患。
5. 社区支持与生态
虽然 npm 是最老牌的包管理工具，拥有广泛的用户基础和丰富的插件生态，但 pnpm 近年来也得到了越来越多开发者的青睐，并且在一些大型项目中被证明是更优的选择。
### index.html 与项目根目录
+ 1，index.html 在项目最外层而不是在 public 文件夹内。这是有意而为之的：在开发期间 Vite 是一个服务器，而 index.html 是该 Vite 项目的入口文件。
+ 2，Vite 将 index.html 视为源码和模块图的一部分。Vite 解析 `<script type="module" src="..."> `，这个标签指向你的 JavaScript 源码。甚至内联引入 JavaScript 的 `<script type="module"> `和引用 CSS 的 `<link href> `也能利用 Vite 特有的功能被解析。另外，index.html 中的 URL 将被自动转换，因此不再需要 %PUBLIC_URL% 占位符了
+ 3,Vite 也支持多个 .html 作入口点的 多页面应用模式。
### 指定替代根目录
执行 vite 命令会以当前工作目录作为根目录启动开发服务器。你也可以通过 vite serve some/sub/dir 来指定一个不同的根目录。 需要注意的是，Vite 也会在项目的根目录中寻找 它的配置文件（即 vite.config.js），所以如果更改了根目录，你需要将配置文件一起移动过去。
### 命令行接口
```package.json
{
  "scripts": {
    "dev": "vite", // 启动开发服务器，别名：`vite dev`，`vite serve`
    "build": "vite build", // 为生产环境构建产物
    "preview": "vite preview" // 本地预览生产构建产物
  }
}
```
## 项目理念
### 精简且可扩展的核心
Vite 的目标不在于满足所有用户的每一个使用场景。Vite 旨在开箱即用地支持构建 Web 应用的最常见的模式，但 Vite 核心包 必须保持精简并拥有较小的 API 接口，以保证项目长期维护的可行性。这一目标之所以可能实现，得益于 Vite 基于 Rollup 的插件系统 。可以作为外部插件实现的功能通常不会添加到 Vite 核心中。 vite-plugin-pwa 是一个很好的示例，展示了 Vite 核心之外能实现的强大功能，并且有许多 维护良好的插件 来满足您的需求。Vite 与 Rollup 项目紧密合作，确保插件在尽可能多的情况下既可用于纯 Rollup 项目，也可用于 Vite 项目，并努力将必要的扩展推送到上游 Plugin API 中。
### 推动现代 Web 开发
Vite 提供了一系列推动编写现代代码的特定功能。例如：
+ 源代码必须采用 ESM 形式编写；对于非 ESM 的依赖项，为了使其正常工作，需要 预先将其打包为 ESM。
+ 建议使用 new Worker 语法 来编写 Web Workers，以遵循现代标准。
+ 在浏览器环境下，不能直接使用 Node.js 模块。

在新增特性时，会遵循这些模式来构建一个具备前瞻性的 API，但请注意，这样的API可能并不总是与其它构建工具兼容。
### 旨在高性能的实用解决方案
其开发服务器架构设计确保了随着项目规模扩大，模块热替换（HMR）仍能保持高速运行。Vite 采用类似 esbuild 和 SWC 这样的原生工具处理复杂的任务，同时将其他部分代码保留在 JavaScript 中，以实现速度与灵活性之间的平衡。在需要时，框架插件会利用 Babel 来编译用户代码。构建阶段，Vite 当前使用的是 Rollup ，此时包体积大小以及能够接入广泛生态系统的插件比原始速度更重要。
### 基于 Vite 构建框架
尽管 Vite 可以直接供用户使用，但它尤其适合作为创建框架的工具。Vite 核心本身不特定于任何框架，但针对每个 UI 框架都提供了完善的插件支持。其 JS API 允许应用框架作者利用 Vite 特性为他们的用户提供定制化的体验。Vite 包含了对 SSR 基础功能 的支持，这些功能通常在更高级别的工具中出现，但对于构建现代 Web 框架至关重要。Vite 插件通过提供一种跨框架共享的方式，使整体方案更为完备。此外，当与诸如 Ruby 和 Laravel 等 后端框架 结合使用时，Vite 也是一个绝佳选择。
## 为什么选 Vite
### 现实问题
在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。

时过境迁，我们见证了诸如 webpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验。

然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。

Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。
### 缓慢的服务器启动
当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。

Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。

+ 依赖 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。

+ Vite 将会使用 esbuild 预构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

+ 源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。

Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。

### 缓慢的更新
基于打包启动时，当源文件被修改后，重新构建整个包是低效的，原因显而易见：更新速度会随着应用体积的增加而线性下降。

一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热替换（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。

在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活[1]（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。

Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

一旦你体验到 Vite 的神速，你可能再也不想回到曾经的打包开发方式了。

### 为什么生产环境仍需打包
尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。
要确保开发服务器和生产环境构建之间的最优输出和行为一致并不容易。所以 Vite 附带了一套 构建优化 的 构建命令，开箱即用。

### 为何不用 ESBuild 打包？
虽然 Vite 利用 esbuild 在开发中预打包一些依赖，但 Vite 不会在生产构建中使用 esbuild 作为打包工具。

Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容。尽管 esbuild 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。

Rollup 已经开始着手改进性能，在 v4 中将其解析器切换到 SWC。同时还有一个正在进行中的工作，即构建一个名为 Rolldown 的 Rust 版本的 Rollup。一旦 Rolldown 准备就绪，它就可以在 Vite 中取代 Rollup 和 esbuild，显著提高构建性能，并消除开发和构建之间的不一致性。
### Vite 与其他免打包构建工具的关系？
Preact 团队的 WMR 旨在提供类似的功能集。Vite 用于开发和构建的通用 Rollup 插件 API 就是受其启发。WMR 已经不再维护。Preact 团队现在推荐使用 Vite 和 @preactjs/preset-vite。

Snowpack 也是一个免打包的原生 ESM 开发服务器，与 Vite 的职责非常相似。Vite 的依赖预打包也受到了 Snowpack v1（现在是 esinstall）的启发。Snowpack 已经不再维护。Snowpack 团队现在正在研究由 Vite 驱动的静态网站构建器 Astro。

@web/dev-server（以前是 es-dev-server）是一个伟大的项目，Vite 1.0 的基于 Koa 的服务器设置就是受其启发。@web 这个项目正在积极维护，并包含许多其他优秀的工具，这些工具也可能对 Vite 用户有所帮助。

